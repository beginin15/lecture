# TDD로 자동차 경주 게임 구현하기

## TDD 시작하기

### 테스트 하기 어려운 부분과 쉬운 부분을 구분하라 📢

- 테스트하기 어려운 UI, DB를 제외한 나머지 도메인부터 TDD를 작성해보자

  </br>

### 도메인 지식, 객체 설계 경험이 있다면 🤓

- 요구사항 분석을 통해 대략적인 설계 (객체 추출)

- UI, DB 등과 의존 관계를 가지지 않는 핵심 도메인 영역을 집중 설계

  </br>

### 객체 설계 역량이 부족하다면 🧐

- 클래스 설계보다 기능 목록을 먼저 작성해보자

  > 기능 목록을 작성하는 것도 연습이 필요하다.

  </br>

### 그래도 어렵다면? 🥺

1. 익숙한 방식으로 일단 구현한다.

2. 구현하고자 하는 프로그램의 도메인 지식을 쌓는다.

3. **구현한 모든 코드를 버린다.**

   > 새롭게 구현하는 것보다 레거시 코드를 리팩토링하는 것이 훨씬 더 어렵다.

4. 기능 목록 작성하거나 간단한 도메인 설계한다.

5. 기능 목록 중 가장 만만한 녀석부터 TDD로 구현을 시작한다.

6. 복잡도가 높아져 리팩토링하기 힘든 상태가 되면 다시 버린다.

7. 다시 도전한다.

   </br>

## 자동차 경주 게임 🚗

### 기능 목록은 진행하면서 꾸준하게 업데이트한다. 

- 처음부터 완벽한 기능 목록은 작성할 수 없다.

- 구현하는 과정에서 발생하는 문제점들이나 처리해야하는 예외 상황을 다시 기능 목록에 작성한다.

  </br>

### <u>1단계</u>

#### Utill 성격의 기능은 Input과 Output이 명확하기 때문에 TDD로 도전하기 좋다.

- TDD의 첫 걸음은 테스트하고자 하는 메소드의 Input과 Output을 결정하는 일이다.

- TDD에 익숙하지 않다면 상태를 가지고 있는 인스턴스 객체는 구현 또는 테스트를 복잡하게 만들 수 있기 때문에 Utill 성격의 기능부터 구현하는 것도 좋다.

  </br>

> 1단계 기능 목록
>
> - 1자 이상, 5자 이하의 정상적인 이름인지 확인 (`ValidationUtils`)
> - 자동차 이동 거리에 따라 "-" 생성하기 (`StringUtils`)

​	</br>

### <u>2단계</u>

#### 테스트 가능한 부분에 대해 TDD로 도전한다.

- 테스트하기 어려운 부분을 제외한 나머지 부분을 TDD로 구현한다.

  > 랜덤, 날짜, 외부 API 사용, DB 요청, UI 구현 등은 테스트하기 어렵다.

  </br>

### `equals()`, `hashCode()`

- 객체 지향 프로그래밍에서 `equals()`, `hashCode()`는 중요한 역할을 한다.

  - 객체 간의 비교를 객체 스스로가 수행하기 때문에 객체 지향적이다.
  - 객체가 가지고 있는 값을 꺼내와서 비교하지말자. 객체에게 맡기자!

- TDD로 구현하다보면 해당 메소드들을 재정의해야 하는 순간이 빨리 온다.

  </br>

> 2단계 기능 목록
>
> - 참여자의 이름을 split하고 자동차 생성하기 (`CarFactory`)
> - 경주에 참여한 자동차 중에서 우승자 찾기 (어려우니까 나중에 구현하자)

​	</br>

### <u>3단계</u>

### 테스트하기 어려운 부분을 찾아 가능한 구조로 개선한다.

- 테스트하기 어려운 부분을 테스트하기 쉽도록 설계를 바꿔야 한다.

  > 어떻게 테스트하기 쉽도록 설계할 수 있을까?

- Object Graph에서 다른 Object와 의존 관계를 갖지 않는 마지막 노드(Node)를 찾아 테스트 가능한지 확인한다.

  - 마지막 노드를 테스트 할 수 있어야 상위 노드도 테스트가 가능해진다.

  > 예를 들어, `RacingMain` => `RacingGame` => `Car`와 같은 의존 관계를 가진다면 **`Car`**가 테스트 가능한지 확인한다.

  > 예시 코드

  ```java
  public class Car {
    
    private static final int FORWARD_NUM = 4;
    private static final int MAX_BOUND = 10;
    
    private int position = 0;
    
    public void move() {
      if (getRandomNo() >= FORWARD_NUM) {
        this.position++;
      }
    }
    
    private int getRandomNo() {
      Random random = new Random();
      return random.nextInt(MAX_BOUND); // 랜덤값이 어떻게 나올지 알 수 없기 때문에 move()는 테스트하기 어렵다.
    }
  }
  ```

  - 현재 `move()` 메소드는  `Random` 에 의존하고 있기 때문에 테스트하기 어렵다.

  <img src="https://user-images.githubusercontent.com/33659848/91993310-2d477800-ed70-11ea-90c9-b60b18dd65df.png" alt="object_graph" style="zoom:50%;" />

  - `Car` 의 `move()`를 테스트하기 어렵다면 그 상위 노드도 모두 테스트하기 어렵다.

- 테스트하기 어려운 코드의 의존 관계를 Object Graph의 상위로 이동시킨다.

  <img src="https://user-images.githubusercontent.com/33659848/91993930-f160e280-ed70-11ea-8d75-65c762d18b77.png" alt="object_graph_up" style="zoom:50%;" />

  - `Random`에 대한 의존성을 그 상위 노드인 `RacingGame` 으로 이동한다면 `Car` 는 테스트 가능한 구조로 변경된다.

    <img src="https://user-images.githubusercontent.com/33659848/91994161-3a189b80-ed71-11ea-8d9a-370c4dfdf7b8.png" alt="object_graph_up_up" style="zoom:50%;" />

  - 테스트하기 어려운 부분(의존성)을 테스트를 수행해야 하는 범위 밖까지 끌어올릴 수 있다.

  </br>

### 테스트하기 어려운 부분을 도메인 클래스로부터 분리한다.

- 대표적으로 테스트하기 어려운 코드

  - 내부 API

    > Random, shuffle, 날짜

  - 외부 API

    > 외부 REST API, 데이터베이스 API

- 위와 같은 코드들은 우리가 작성하는 도메인 클래스로부터 분리해야 테스트하기 쉽다.

  </br>

> 3단계 기능 목록
>
> - 자동차 이동 유무
>
> - 우승자 이름 출력하기

​	</br>

### <u>4단계</u>

#### 다음 기준으로 리팩토링을 진행한다.

- 규칙 1: 한 메소드에 오직 한 단계의 들여쓰기(indent)만 한다.

  > 메소드를 사용하면 indent가 줄어든다. 즉, 메소드를 만드는 연습

- 규칙 2: else 예약어를 쓰지 않는다.

- 규칙 3: 모든 원시값과 문자열을 포장한다.

- 규칙 8: 일급 컬렉션을 사용한다.

  > 규칙 3과 8은 클래스를 분리하는 연습

  </br>

### 모든 원시값과 문자열을 포장한다.

- 도메인 클래스의 로직 복잡도가 줄어든다. (내 개인적인 생각. 나중에 객체 지향 체조 읽어보자. 📌)

  - 객체가 가지고 있는 여러 값에 대한 유효성 검증 로직을 각 Wrapper 클래스에게 전임할 수 있다.

    > 예를 들어, `Car` 클래스가 이름을 표현하는 **문자열**과 위치를 표현하는 **정수값**을 가지고 있다면 해당 값들에 대한 유효성 검사를 `Car`  또는 그 상위 노드에서 처리해야 한다.
    >
    > => 값들을 각자 클래스로 포장한다면 해당 클래스에서 값에 대한 유효성 검증을 수행할 수 있다.

- 클래스가 많아지는 것을 당연하게 생각하자.

  - 클래스가 많아지더라도 각자의 역할이 분명하다면 의미있는 분리이다.

    > 반대로 하는 일이 없다면 클래스로 만들 필요는 없다.

  - 단일 책임의 원칙을 적용할 수 있어 클래스의 코드가 간단해지고 가독성도 좋아진다.

  - 아직 발생하지 않은 성능 문제보다 유지 보수와 가독성을 우선시하자.

    > 물론 성능 문제가 발생하면 그때 가서 해결하면 된다.

  </br>

### 일급 컬렉션을 사용한다.

- 원시값과 문자열을 포장하듯이 컬렉션도 포장한다.

  </br>

## 다음 개인 목표

다음 미션 때는 아래 내용들을 의식하면서 구현해보자

- 기능 목록을 작은 단위로 나누기

- TDD 사이클 지키기

- 리팩토링을 진행할 때 초록 막대 주기 짧게 갖기

- 극단적으로 모든 문자열과 원시값 포장하기

- IntelliJ에서 상수를 멤버로 추출하기, 특정 부분을 메소드로 추출하기 기능 사용해보기

  </br>

## 기타

### 도메인

- 핵심 비즈니스 로직을 가지고 있는 클래스

- UI, DB에 의존적이지 않아야 한다.

  </br>

### TDD 미션 활용하기

- 미션을 주기적으로 반복해서 구현해본다. 단, 매번 새로운 목표를 세워야 한다.

- 새로운 언어를 배울 때, TDD 미션을 해당 언어로 구현해본다.

  </br>

### 들여쓰기를 자제하는 이유

- indent가 깊어질수록 코드의 가독성이 떨어진다.

- else문을 제한하는 이유도 마찬가지이다.

  </br>

### Object Graph

- 객체간의 의존 관계를 의미한다.

  </br>

## 참고

[TDD로 자동차 경주 게임 구현하기 - pdf 자료](https://nextstep-storage.s3.ap-northeast-2.amazonaws.com/682cc73b6ea44a7a9c4a5f91f59e0bda)

