# IoC 컨테이너 1부

## 스코프

### 싱글톤

- 기본적으로 빈은 싱글톤 스코프이다.

- 싱글톤 클래스는 thread-safe 하게 코딩해야 한다.

  > 싱글톤 클래스가 상태를 가지고 있으면 각 스레드에서 변경될 여지가 존재하므로 thread-safe하지 못하다.

- [구현 코드]()



### 프로토타입

- `ApplicationContext`에서 가져올 때마다 새로운 객체를 생성한다.

- 종류
  - Request
  - Session
  - WebSocket
  - 등등



### 스코프 설정하기

- `@Scope` 어노테이션을 사용한다.

> [구현 코드]()



### 서로 다른 스코프의 객체 참조

> 서로 다른 스코프를 가진 객체에 의존하는 경우, 의도하지 않은 문제가 발생할 수 있다!

- **프로토타입** 스코프 객체가 **싱글톤** 스코프 객체를 참조하는 경우 => **문제 없음**

  - 프로토타입은 매번 생성되고, 해당 객체가 참조하는 싱글톤은 주소가 항상 동일하므로

  > [구현 코드]()

- **싱글톤** 스코프 객체가 **프로토타입** 스코프 객체를 참조하는 경우 => **문제 발생**

  - 싱글톤은 딱 한번 생성되므로, 의존 객체인 프로토타입도 덩달아 딱 한번만 생성된다. (바뀔 여지가 없다.)
  - 위 경우는 프로토타입 스코프를 사용한 의미가 없어지기 때문에 의도한 바와 달라 문제가 발생할 수 있다!

  > [구현 코드]()



### 해결 방법

1. 프록시 모드

   - `@Scope` 에서 제공하는 `proxyMode` 옵션을 사용한다.

   - `@Scope`가 붙은 클래스의 인스턴스를 프록시 빈으로 감싼다.

   - `ApplicationContext`는 프로토타입 객체 대신 프록시 빈으로 의존성을 주입해준다.

     > 프록시 빈은 프로토타입 클래스를 상속받아서 구현되므로 프로토타입과 동일한 타입으로 주입이 가능한 것이다.

   - 프록시 빈은 지정한 스코프에 따르기 때문에 싱글톤 객체가 프로토타입 객체를 참조하는 경우, 의도한 바대로 매번 새로운 객체를 받을 수 있다.

   > [구현 코드]()

2. `ObjectProvider`

   - 프로토타입 객체를 직접 참조하지 않고  `ObjectProvider` 를 이용하여 프로토타입 객체를 가져온다.
   - 다만, 해당 클래스를 의존 객체로 참조하고 있는 모습은 POJO 스럽지 못하다는 단점이 있다.

   > [구현 코드]()